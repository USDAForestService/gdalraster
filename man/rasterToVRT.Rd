% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gdalraster_proc.R
\name{rasterToVRT}
\alias{rasterToVRT}
\title{Create a GDAL virtual raster}
\usage{
rasterToVRT(
  srcfile,
  relativeToVRT = FALSE,
  vrtfile = tempfile("tmprast", fileext = ".vrt"),
  resolution = NULL,
  subwindow = NULL,
  align = TRUE,
  resampling = "nearest",
  krnl = NULL,
  normalized = TRUE
)
}
\arguments{
\item{srcfile}{Source raster filename.}

\item{relativeToVRT}{Logical. Indicates whether the source filename should
be interpreted as relative to the .vrt file (\code{TRUE}) or not relative
to the .vrt file (\code{FALSE}, the default). If \code{TRUE}, the .vrt
file is assumed to be in the same directory as \code{srcfile} and
\code{basename(srcfile)} is used in the .vrt file. Use \code{TRUE} if the .vrt file
will always be stored in the same directory with \code{srcfile}.}

\item{vrtfile}{Output VRT filename.}

\item{resolution}{A numeric vector of length two (xres, yres). The pixel
size must be expressed in georeferenced units. Both must be positive values.
The source pixel size is used if \code{resolution} is not specified.}

\item{subwindow}{A numeric vector of length four (xmin, ymin, xmax, ymax).
Selects \code{subwindow} of the source raster with corners given in
georeferenced coordinates (in the source CRS).
If not given, the upper left corner of the VRT will be the
same as source, and the VRT extent will be the same or larger than source
depending on \code{resolution}.}

\item{align}{Logical.
\itemize{
\item \code{TRUE}: the upper left corner of the VRT extent will be set to the
upper left corner of the source pixel that contains \code{subwindow} xmin, ymax.
The VRT will be pixel-aligned with source if the VRT \code{resolution} is the
same as the source pixel size, otherwise VRT extent will be the minimum
rectangle that contains \code{subwindow} for the given pixel size.
\item \code{FALSE}: the VRT upper left corner will be exactly \code{subwindow}
xmin, ymax, and the VRT extent will be the minimum rectangle that contains
\code{subwindow} for the given pixel size. If \code{subwindow} is not given, the
source raster extent is used in which case \code{align=FALSE} has no effect.
}}

\item{resampling}{The resampling method to use if xsize, ysize of the VRT is
different than the size of the underlying source rectangle (in number of
pixels). The values allowed are nearest, bilinear, cubic, cubicspline,
lanczos, average and mode (as character).}

\item{krnl}{A filtering kernel specified as pixel coefficients.
\code{krnl} is a array with dimensions (size, size), where
size must be an odd number. \code{krnl} can also be given as a vector with
length size x size. For example, a 3x3 average filter is given by:
\preformatted{
krnl <- c(
0.11111, 0.11111, 0.11111,
0.11111, 0.11111, 0.11111,
0.11111, 0.11111, 0.11111)
}
A kernel cannot be applied to sub-sampled or over-sampled data.}

\item{normalized}{Logical. Indicates whether the kernel is normalized.
Defaults to \code{TRUE}.}
}
\value{
Returns the VRT filename invisibly.
}
\description{
\code{rasterToVRT()} creates a virtual raster dataset (VRT format) derived from
a source raster with options for virtual subsetting, virtually resampling
the source data at a different pixel resolution, or applying a virtual
kernel filter.
}
\details{
A VRT dataset is saved as a plain-text file with extension .vrt. This file
contains a description of the dataset in an XML format. The description
includes the source raster filename which can be a full path
(\code{relativeToVRT = FALSE}) or the just the filename with no path
(\code{relativeToVRT = TRUE}) in which case \code{rasterToVRT()} assumes that the
.vrt file will be in the same directory as the source file. The different
elements of the XML schema specify how the source data will be read, along
with algorithms potentially applied and so forth. The full specification of
the XML format for .vrt is at:
\url{https://gdal.org/drivers/raster/vrt.html}.

Since .vrt is a small plain-text file it is fast to write and requires
little storage space. Read performance is not degraded for certain simple
operations (e.g., virtual clip without resampling). Reading will be
slower for virtual resampling to a different pixel resolution or virtual
kernel filtering since the operations are performed on-the-fly (but .vrt
does not require the up front writing of a resampled or kernel-filtered
raster to a regular format). VRT is sometimes useful as an intermediate
raster in a series of processing steps, including as a \code{tempfile} (the
default).

Note that the GDAL VRT format has several capabilities and uses beyond
those covered by \code{rasterToVRT()}. See the format description URL above for
a full discussion. \code{\link[=warp]{warp()}} can write to VRT format for virtual
reprojection.

\code{rasterToVRT()} assumes \code{srcfile} is a north-up raster.
Requires package \code{xml2}.
}
\examples{
## resample

evt_file <- system.file("extdata/storml_evt.tif", package="gdalraster")
ds <- new(GDALRaster, evt_file, TRUE)
ds$res()
ds$bbox()
ds$close()

## using combine() with one input to get a table of pixel counts for each 
## raster value
vat <- combine(evt_file)
print(vat[-1]) # drop the cmbid in this case
sum(vat$count)

## resample at 90-m resolution
## EVT is thematic vegetation type so use a majority value
vrt_file <- rasterToVRT(evt_file,
                        resolution=c(90,90),
                        resampling="mode")

## .vrt is a small plain-text xml file pointing to the source raster
file.size(vrt_file)

vat90m <- combine(vrt_file, var.names=c("evt90m"))
print(vat90m[-1])
sum(vat90m$count)

ds <- new(GDALRaster, vrt_file, TRUE)
ds$res()
ds$bbox()
ds$close()

## clip

evt_file <- system.file("extdata/storml_evt.tif", package="gdalraster")
ds_evt <- new(GDALRaster, evt_file, TRUE)
ds_evt$bbox()

## WKT string for a boundary within the EVT extent
bnd = "POLYGON ((324467.3 5104814.2, 323909.4 5104365.4, 323794.2 
5103455.8, 324970.7 5102885.8, 326420.0 5103595.3, 326389.6 5104747.5, 
325298.1 5104929.4, 325298.1 5104929.4, 324467.3 5104814.2))"

## align = TRUE
vrt_file <- rasterToVRT(evt_file,
                        subwindow = bbox_from_wkt(bnd),
                        align=TRUE)
ds_vrt <- new(GDALRaster, vrt_file, TRUE)

## VRT is a virtual clip, pixel-aligned with the EVT raster
bbox_from_wkt(bnd)
ds_vrt$bbox()
ds_vrt$res()

## align = FALSE
vrt_file <- rasterToVRT(evt_file,
                        subwindow = bbox_from_wkt(bnd),
                        align=FALSE)
ds_vrt_noalign <- new(GDALRaster, vrt_file, TRUE)

## VRT upper left corner (xmin, ymax) is exactly bnd xmin, ymax
ds_vrt_noalign$bbox()
ds_vrt_noalign$res()

ds_vrt$close()
ds_vrt_noalign$close()
ds_evt$close()
}
\seealso{
\code{\link[=bbox_from_wkt]{bbox_from_wkt()}}
}
