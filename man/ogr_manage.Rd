% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ogr_manage.R
\name{ogr_manage}
\alias{ogr_manage}
\alias{ogr_ds_exists}
\alias{ogr_ds_test_cap}
\alias{ogr_ds_create}
\alias{ogr_ds_layer_count}
\alias{ogr_ds_layer_names}
\alias{ogr_layer_exists}
\alias{ogr_layer_create}
\alias{ogr_layer_fld_names}
\alias{ogr_layer_delete}
\alias{ogr_field_index}
\alias{ogr_field_create}
\alias{ogr_geom_field_create}
\alias{ogr_field_delete}
\alias{ogr_execute_sql}
\title{Utility functions for managing vector data sources}
\usage{
ogr_ds_exists(dsn, with_update = FALSE)

ogr_ds_test_cap(dsn, with_update = TRUE)

ogr_ds_create(
  format,
  dsn,
  layer = NULL,
  layer_defn = NULL,
  geom_type = NULL,
  srs = NULL,
  fld_name = NULL,
  fld_type = NULL,
  dsco = NULL,
  lco = NULL
)

ogr_ds_layer_count(dsn)

ogr_ds_layer_names(dsn)

ogr_layer_exists(dsn, layer)

ogr_layer_create(
  dsn,
  layer,
  layer_defn = NULL,
  geom_type = NULL,
  srs = NULL,
  lco = NULL
)

ogr_layer_fld_names(dsn, layer)

ogr_layer_delete(dsn, layer)

ogr_field_index(dsn, layer, fld_name)

ogr_field_create(
  dsn,
  layer,
  fld_name,
  fld_defn = NULL,
  fld_type = "OFTInteger",
  fld_subtype = "OFSTNone",
  fld_width = 0,
  fld_precision = 0,
  is_nullable = TRUE,
  is_ignored = FALSE,
  is_unique = FALSE,
  default_value = ""
)

ogr_geom_field_create(
  dsn,
  layer,
  fld_name,
  geom_fld_defn = NULL,
  geom_type = NULL,
  srs = NULL,
  is_nullable = TRUE,
  is_ignored = FALSE
)

ogr_field_delete(dsn, layer, fld_name)

ogr_execute_sql(dsn, sql, spatial_filter = NULL, dialect = NULL)
}
\arguments{
\item{dsn}{Character string. The vector data source name, e.g., a filename
or database connection string.}

\item{with_update}{Logical scalar. \code{TRUE} to request update access when
opening the dataset, or \code{FALSE} to open read-only.}

\item{format}{GDAL short name of the vector format as character string.
Examples of some common output formats include: \code{"GPKG"}, \code{"FlatGeobuf"},
\code{"ESRI Shapefile"}, \code{"SQLite"}.}

\item{layer}{Character string for a layer name in a vector dataset.}

\item{layer_defn}{A feature class definition for \code{layer} as a list of
zero or more attribute field definitions, and at least one geometry field
definition (see Details).
Each field definition is a list with named elements containing values for
the field type and other properties.
If \code{layer_defn} is given, it will be used and any additional parameters
passed that relate to the feature class definition will be ignored (i.e.,
\code{geom_type} and \code{srs}, as well as \code{fld_name} and \code{fld_type} in
\code{ogr_ds_create()}).
The first geometry field definition in \code{layer_defn} defines the
\code{geom_type} and \code{srs} for the layer.}

\item{geom_type}{Character string specifying a geometry type (see Details).}

\item{srs}{Character string containing a spatial reference system definition
as OGC WKT or other well-known format (e.g., the input formats usable with
\code{\link[=srs_to_wkt]{srs_to_wkt()}}).}

\item{fld_name}{Character string containing the name of an attribute field
in \code{layer}.}

\item{fld_type}{Character string containing the name of a field data type
(e.g., \code{OFTInteger}, \code{OFTReal}, \code{OFTString}, see Details.)}

\item{dsco}{Optional character vector of format-specific creation options
for \code{dsn} (\code{"NAME=VALUE"} pairs).}

\item{lco}{Optional character vector of format-specific creation options
for \code{layer} (\code{"NAME=VALUE"} pairs).}

\item{fld_defn}{A field definition as list (see Details). Additional
arguments in \code{ogr_field_create()} will be ignored if a \code{fld_defn} is given.}

\item{fld_subtype}{Character string containing the name of a field subtype.
One of  \code{OFSTNone} (the default), \code{OFSTBoolean}, \code{OFSTInt16}, \code{OFSTFloat32},
\code{OFSTJSON}, \code{OFSTUUID}.}

\item{fld_width}{Optional integer scalar specifying max number of characters.}

\item{fld_precision}{Optional integer scalar specifying number of digits
after the decimal point.}

\item{is_nullable}{Optional NOT NULL field constraint (logical scalar).
Defaults to \code{TRUE}.}

\item{is_ignored}{Whether field is ignored when retrieving features (logical
scalar). Defaults to \code{FALSE}.}

\item{is_unique}{Optional UNIQUE constraint on the field (logical scalar).
Defaults to \code{FALSE}.}

\item{default_value}{Optional default value for the field as a character
string.}

\item{geom_fld_defn}{A geometry field definition as list (see Details).
Additional arguments in \code{ogr_geom_field_create()} will be ignored if a
\code{geom_fld_defn} is given.}

\item{sql}{Character string containing an SQL statement (see Note).}

\item{spatial_filter}{Either a numeric vector of length four containing a
bounding box (xmin, ymin, xmax, ymax), or a character string containing a
geometry as OGC WKT, representing a spatial filter.}

\item{dialect}{Character string specifying the SQL dialect to use.
The OGR SQL engine (\code{"OGRSQL"}) will be used by default if a value is not
given. The \code{"SQLite"} dialect can also be used (see Note).}
}
\description{
This set of management functions can be used to create new vector datasets,
test existence of dataset/layer/field, test dataset capabilities,
create new layers in an existing dataset, delete layers, create new
attribute and geometry fields on an existing layer, and delete fields.
}
\details{
\subsection{Utilities for vector data sources}{

These functions should be complementary to \code{ogrinfo()} and \code{ogr2ogr()} for
vector data management. Bindings to OGR wrap portions of the GDAL Vector
API (ogr_core.h and ogr_api.h, \link{https://gdal.org/api/vector_c_api.html}).

\code{ogr_ds_exists()} tests whether a vector dataset can be opened from the
given data source name (DSN), potentially testing for update access.
Returns a logical scalar.

\code{ogr_ds_test_cap()} tests the capabilities of a vector dataset, attempting
to open it with update access by default. Returns a list of capabilities
with values \code{TRUE} or \code{FALSE}, or \code{NULL} is returned if \code{dsn} cannot be
opened with the requested access. The returned list elements include the
following:
\itemize{
\item \code{CreateLayer}: \code{TRUE} if this datasource can create new layers
\item \code{DeleteLayer}: \code{TRUE} if this datasource can delete existing layers
\item \code{CreateGeomFieldAfterCreateLayer}: \code{TRUE} if the layers of this
datasource support geometry field creation just after layer creation
\item \code{CurveGeometries}: \code{TRUE} if this datasource supports curve geometries
\item \code{Transactions}: \code{TRUE} if this datasource supports (efficient)
transactions
\item \code{EmulatedTransactions}: \code{TRUE} if this datasource supports transactions
through emulation
\item \code{RandomLayerRead}: \code{TRUE} if this datasource has a dedicated
\code{GetNextFeature()} implementation, potentially returning features from
layers in a non-sequential way
\item \code{RandomLayerWrite}: \code{TRUE} if this datasource supports calling
\code{CreateFeature()} on layers in a non-sequential way
}

\code{ogr_ds_create()} creates a new vector datasource, optionally also creating
a layer, and optionally creating one or more fields on the layer.
The attribute fields and geometry field(s) to create can be specified as a
feature class definition (\code{layer_defn} as list, see below), or
alternatively, by giving the \code{geom_type} and \code{srs}, optionally along with
one \code{fld_name} and \code{fld_type} to be created in the layer. Returns a logical
scalar, \code{TRUE} indicating success.

\code{ogr_ds_layer_count()} returns the number of layers in a vector dataset.

\code{ogr_ds_layer_names()} returns a character vector of layer names in a
vector dataset, or \code{NULL} if no layers are found.

\code{ogr_layer_exists()} tests whether a layer can be accessed by name in a
given vector dataset. Returns a logical scalar.

\code{ogr_layer_create()} creates a new layer in a vector dataset, with a
specified geometry type and spatial reference definition. This function also
accepts a feature class definition given as a list of field names and their
definitions (see below). Returns a logical scalar, \code{TRUE} indicating success.

\code{ogr_layer_fld_names()} returns a character vector of field names on a
layer, or \code{NULL} if no fields are found.

\code{ogr_layer_delete()} deletes an existing layer in a vector dataset.
Returns a logical scalar, \code{TRUE} indicating success.

\code{ogr_field_index()} tests for existence of an attribute field by name.
Returns the field index on the layer (0-based), or \code{-1} if the field does
not exist.

\code{ogr_field_create()} creates a new attribute field of specified data type in
a given DSN/layer. Several optional field properties can be specified in
addition to the type. Returns a logical scalar, \code{TRUE} indicating success.

\code{ogr_geom_field_create()} creates a new geometry field of specified type in
a given DSN/layer. Returns a logical scalar, \code{TRUE} indicating success.

\code{ogr_field_delete()} deletes an existing field on a vector layer.
Not all format drivers support this function. Some drivers may only support
deleting a field while there are still no features in the layer.
Returns a logical scalar, \code{TRUE} indicating success.

\code{ogr_execute_sql()} executes an SQL statement against the data store.
This function can be used to modify the schema or edit data using SQL
(e.g., \verb{ALTER TABLE}, \verb{DROP TABLE}, \verb{CREATE INDEX}, \verb{DROP INDEX}, \code{INSERT},
\code{UPDATE}, \code{DELETE}). Currently, this function does not return a result set
for a \code{SELECT} statement. Returns \code{NULL} invisibly.
}

\subsection{Feature class definition}{

All features in an OGR Layer share a common schema (feature class), modeled
in GDAL as OGR Feature Definition. The feature class definition includes the
set of attribute fields and their data types and the geometry field(s).
In R, a feature class definition is represented as a list, having as names
the attribute/geometry field names, with each list element holding a field
definition.

An attribute field definition is a list with named elements:

\if{html}{\out{<div class="sourceCode">}}\preformatted{$type       : OGR Field Type ("OFTReal", "OFTString" etc.)
$subtype    : optional ("OFSTBoolean", ...)
$width      : optional max number of characters
$precision  : optional number of digits after the decimal point
$is_nullable: optional NOT NULL constraint (logical scalar)
$is_unique  : optional UNIQUE constraint (logical scalar)
$default    : optional default value as character string
$is_ignored : optionally ignored when retrieving features (logical scalar)
$is_geom    : FALSE (the default) for attribute fields
}\if{html}{\out{</div>}}

An OGR field type is specified as a character string with possible values:
\code{OFTInteger}, \code{OFTIntegerList}, \code{OFTReal}, \code{OFTRealList}, \code{OFTString},
\code{OFTStringList}, \code{OFTBinary},  \code{OFTDate}, \code{OFTTime}, \code{OFTDateTime},
\code{OFTInteger64}, \code{OFTInteger64List}.

An optional field subtype is specified as a character string with possible
values:
\code{OFSTNone}, \code{OFSTBoolean}, \code{OFSTInt16}, \code{OFSTFloat32}, \code{OFSTJSON},
\code{OFSTUUID}.

A geometry field definition is a list with named elements:

\if{html}{\out{<div class="sourceCode">}}\preformatted{$type       : geom type ("Point", "Polygon", etc.)
$srs        : optional spatial reference as WKT string
$is_nullable: optional NOT NULL constraint (logical scalar)
$is_ignored : optionally ignored when retrieving features (logical scalar)
$is_geom    : TRUE (required) for geometry fields
}\if{html}{\out{</div>}}

Typically, there is one geometry field on a layer, but some formats support
more than one geometry column per table (e.g., PostGIS).

Geometry types are specified as a character string containing OGC WKT.
Common types include: \code{Point}, \code{LineString}, \code{Polygon}, \code{MultiPoint},
\code{MultiLineString}, \code{MultiPolygon}. See the GDAL documentation for a list
of all supported geometry types:\cr
\link{https://gdal.org/api/vector_c_api.html#_CPPv418OGRwkbGeometryType}

Format drivers may or may not support not-null constraints on attribute and
geometry fields. If they support creating fields with not-null constraints,
this is generally before creating any features to the layer. In some cases,
a not-null constraint may be available as a layer creation option. For
example, GeoPackage format has a layer creation option
\verb{GEOMETRY_NULLABLE=[YES/NO]}.
}
}
\note{
The OGR SQL document linked under \strong{See Also} contains information on the
SQL dialect supported internally by OGR. Some format drivers (e.g., PostGIS)
pass the SQL directly through to the underlying RDBMS (unless \code{OGRSQL} is
explicitly passed as the dialect). The SQLite dialect can also be requested
with the \code{SQLite} string passed as the \code{dialect} argument of
\code{ogr_execute_sql()}. This assumes that GDAL/OGR is built with support for
SQLite, and preferably also with Spatialite support to benefit from spatial
functions. The GDAL document for the SQLite dialect has detailed information.

Other SQL dialects may also be present for some vector formats.
For example, the \code{"INDIRECT_SQLITE"} dialect could potentially be used with
GeoPackage format (\link{https://gdal.org/drivers/vector/gpkg.html#sql}).

\code{ogrinfo()} can also be used to edit data with SQL statements (GDAL >= 3.7).
}
\seealso{
\code{\link[=ogrinfo]{ogrinfo()}}, \code{\link[=ogr2ogr]{ogr2ogr()}}

WKT representation of geometry:\cr
\link{https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry}

OGR SQL dialect:\cr
\link{https://gdal.org/user/ogr_sql_dialect.html}

SQLite dialect:\cr
\link{https://gdal.org/user/sql_sqlite_dialect.html#sql-sqlite-dialect}
}
