# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Apply geotransform
#'
#' `_apply_geotransform()` applies geotransform coefficients to a raster 
#' coordinate in pixel/line space (colum/row), converting into a 
#' georeferenced (x, y) coordinate.
#'
#' @param gt Numeric vector of length six containing the geotransform to 
#' apply.
#' @param pixel Numeric scalar. A raster pixel (column) coordinate.
#' @param line Numeric scalar. A raster line (row) coordinate.
#' @returns Numeric vector of length two containing a geospatial x/y 
#' coordinate (spatial reference system of `gt`).
#' @seealso [`GDALRaster$getGeoTransform()`][GDALRaster], [get_pixel_line()], 
#' [inv_geotransform()]
#' @noRd
NULL

#' Get GDAL version
#'
#' `gdal_version()` returns runtime version information.
#'
#' @returns Character vector of length four containing:
#'   * "–version" - one line version message, e.g., “GDAL 3.6.3, released 
#'   2023/03/12”
#'   * "GDAL_VERSION_NUM" - formatted as a string, e.g., “30603000” for 
#'   GDAL 3.6.3.0
#'   * "GDAL_RELEASE_DATE" - formatted as a string, e.g., “20230312”
#'   * "GDAL_RELEASE_NAME" - e.g., “3.6.3”
#' @examples
#' gdal_version()
gdal_version <- function() {
    .Call(`_gdalraster_gdal_version`)
}

#' Get GDAL configuration option
#'
#' `get_config_option()` gets the value of GDAL runtime configuration option.
#' Configuration options are essentially global variables the user can set.
#' They are used to alter the default behavior of certain raster format 
#' drivers, and in some cases the GDAL core. For a full description and 
#' listing of available options see 
#' \url{https://gdal.org/user/configoptions.html}.
#'
#' @param key Character name of a configuration option.
#' @returns Character. The value of a (key, value) option previously set with 
#' `set_config_option()`. An empty string (`""`) is returned if `key` is not 
#' found.
#' @seealso
#' [set_config_option()]
#' @examples
#' ## this option is set during initialization of the gdalraster package
#' get_config_option("OGR_CT_FORCE_TRADITIONAL_GIS_ORDER")
get_config_option <- function(key) {
    .Call(`_gdalraster_get_config_option`, key)
}

#' Set GDAL configuration option
#'
#' `set_config_option()` sets a GDAL runtime configuration option. 
#' Configuration options are essentially global variables the user can set.
#' They are used to alter the default behavior of certain raster format 
#' drivers, and in some cases the GDAL core. For a full description and 
#' listing of available options see 
#' \url{https://gdal.org/user/configoptions.html}.
#'
#' @param key Character name of a configuration option.
#' @param value Character value to set for the option. 
#' `value = ""` (empty string) will unset a value previously set by 
#' `set_config_option()`.
#' @returns Nothing.
#' @seealso
#' [get_config_option()]
#' @examples
#' set_config_option("GDAL_CACHEMAX", "64")
#' get_config_option("GDAL_CACHEMAX")
#' ## unset:
#' set_config_option("GDAL_CACHEMAX", "")
set_config_option <- function(key, value) {
    invisible(.Call(`_gdalraster_set_config_option`, key, value))
}

#' Create a new uninitialized raster
#'
#' `create()` makes an empty raster in the specified format.
#'
#' @param format Raster format short name (e.g., "GTiff" or "HFA").
#' @param dst_filename Filename to create.
#' @param xsize Integer width of raster in pixels.
#' @param ysize Integer height of raster in pixels.
#' @param nbands Integer number of bands.
#' @param dataType Character data type name.
#' (e.g., common data types include Byte, Int16, UInt16, Int32, Float32).
#' @param options Optional list of format-specific creation options in a
#' vector of "NAME=VALUE" pairs 
#' (e.g., \code{options = c("COMPRESS=LZW")} to set LZW 
#' compression during creation of a GTiff file).
#' The APPEND_SUBDATASET=YES option can be 
#' specified to avoid prior destruction of existing dataset.
#' @returns Logical indicating success (invisible \code{TRUE}).
#' An error is raised if the operation fails.
#' @seealso
#' [`GDALRaster-class`][GDALRaster], [createCopy()], [rasterFromRaster()]
#' @examples
#' new_file <- paste0(tempdir(), "/", "newdata.tif")
#' create("GTiff", new_file, 143, 107, 1, "Int16")
#' ds <- new(GDALRaster, new_file, read_only=FALSE)
#' ## EPSG:26912 - NAD83 / UTM zone 12N
#' ds$setProjection(epsg_to_wkt(26912))
#' gt <- c(323476.1, 30, 0, 5105082.0, 0, -30)
#' ds$setGeoTransform(gt)
#' ds$setNoDataValue(band = 1, -9999)
#' ds$fillRaster(band = 1, -9999, 0)
#' ## ...
#' ## close the dataset when done
#' ds$close()
create <- function(format, dst_filename, xsize, ysize, nbands, dataType, options = NULL) {
    invisible(.Call(`_gdalraster_create`, format, dst_filename, xsize, ysize, nbands, dataType, options))
}

#' Create a copy of a raster
#'
#' `createCopy()` copies a raster dataset, optionally changing the format.
#' The extent, cell size, number of bands, data type, projection, and 
#' geotransform are all copied from the source raster.
#'
#' @param format Format short name for the output raster 
#' (e.g., "GTiff" or "HFA").
#' @param dst_filename Filename to create.
#' @param src_filename Filename of source raster.
#' @param strict Logical. TRUE if the copy must be strictly equivalent, 
#' or more normally FALSE indicating that the copy may adapt as needed for  
#' the output format.
#' @param options Optional list of format-specific creation options in a
#' vector of "NAME=VALUE" pairs 
#' (e.g., \code{options = c("COMPRESS=LZW")} to set \code{LZW}
#' compression during creation of a GTiff file).
#' The APPEND_SUBDATASET=YES option can be 
#' specified to avoid prior destruction of existing dataset.
#' @returns Logical indicating success (invisible \code{TRUE}).
#' An error is raised if the operation fails.
#' @seealso
#' [`GDALRaster-class`][GDALRaster], [create()], [rasterFromRaster()]
#' @examples
#' lcp_file <- system.file("extdata/storm_lake.lcp", package="gdalraster")
#' tif_file <- paste0(tempdir(), "/", "storml_lndscp.tif")
#' options <- c("COMPRESS=LZW")
#' createCopy("GTiff", tif_file, lcp_file, options=options)
#' file.size(lcp_file)
#' file.size(tif_file)
#' ds <- new(GDALRaster, tif_file, read_only=FALSE)
#' ds$getMetadata(0, "IMAGE_STRUCTURE")
#' for (band in 1:ds$getRasterCount())
#'     ds$setNoDataValue(band, -9999)
#' ds$getStatistics(band=1, approx_ok=FALSE, force=TRUE)
#' ds$close()
createCopy <- function(format, dst_filename, src_filename, strict = FALSE, options = NULL) {
    invisible(.Call(`_gdalraster_createCopy`, format, dst_filename, src_filename, strict, options))
}

#' Invert geotransform
#'
#' `inv_geotransform()` inverts a vector of geotransform coefficients. This 
#' converts the equation from being:\cr
#' raster pixel/line (column/row) -> geospatial x/y coordinate\cr
#' to:\cr
#' geospatial x/y coordinate -> raster pixel/line (column/row)
#'
#' @param gt Numeric vector of length six containing the geotransform to 
#' invert.
#' @returns Numeric vector of length six containing the inverted 
#' geotransform. The output vector will contain NAs if the input geotransform
#' is uninvertable.
#' @seealso [`GDALRaster$getGeoTransform()`][GDALRaster], [get_pixel_line()]
#' @examples
#' elev_file <- system.file("extdata/storml_elev.tif", package="gdalraster")
#' ds <- new(GDALRaster, elev_file, read_only=TRUE)
#' gt <- ds$getGeoTransform()
#' ds$close()
#' invgt <- inv_geotransform(gt)
#' 
#' ptX = 324181.7
#' ptY = 5103901.4
#' 
#' ## for a point x, y in the spatial reference system of elev_file
#' ## raster pixel (column number):
#' pixel <- floor(invgt[1] +
#'                invgt[2] * ptX +
#'                invgt[3] * ptY)
#' 
#' ## raster line (row number):
#' line <- floor(invgt[4] +
#'               invgt[5] * ptX +
#'               invgt[6] * ptY)
#' 
#' ## get_pixel_line() applies this conversion
inv_geotransform <- function(gt) {
    .Call(`_gdalraster_inv_geotransform`, gt)
}

#' Raster pixel/line from geospatial x,y coordinates
#'
#' `get_pixel_line()` converts geospatial coordinates to pixel/line (raster 
#' column, row numbers).
#' The upper left corner pixel is the raster origin (0,0) with column, row
#' increasing left to right, top to bottom.
#'
#' @param xy Numeric array of geospatial x,y coordinates in the same
#' spatial reference system as \code{gt}. 
#' @param gt Numeric vector of length six. The affine geotransform for the 
#' raster.
#' @returns Integer array of raster pixel/line.
#'
#' @seealso [`GDALRaster$getGeoTransform()`][GDALRaster], [inv_geotransform()]
#'
#' @examples
#' pt_file <- system.file("extdata/storml_pts.csv", package="gdalraster")
#' ## id, x, y in NAD83 / UTM zone 12N
#' pts <- read.csv(pt_file)
#' print(pts)
#' raster_file <- system.file("extdata/storm_lake.lcp", package="gdalraster")
#' ds <- new(GDALRaster, raster_file, TRUE)
#' gt <- ds$getGeoTransform()
#' get_pixel_line(as.matrix(pts[,-1]), gt)
#' ds$close()
get_pixel_line <- function(xy, gt) {
    .Call(`_gdalraster_get_pixel_line`, xy, gt)
}

#' Raster reprojection
#'
#' `warp()` is a wrapper for the \command{gdalwarp} command-line utility.
#' See \url{https://gdal.org/programs/gdalwarp.html} for details.
#'
#' @param src_files Character vector of source file(s) to be reprojected.
#' @param dst_filename Filename of the output raster.
#' @param t_srs Character. Target spatial reference system. Usually an EPSG 
#' code ("EPSG:#####") or a well known text (WKT) SRS definition.
#' @param cl_arg Optional character vector of command-line arguments to 
#' \code{gdalwarp} in addition to -t_srs.
#' @returns Logical indicating success (invisible \code{TRUE}).
#' An error is raised if the operation fails.
#'
#' @seealso
#' [`GDALRaster-class`][GDALRaster], [srs_to_wkt()]
#'
#' @examples
#' ## reproject the elevation raster to NAD83 / CONUS Albers (EPSG:5070)
#' elev_file <- system.file("extdata/storml_elev.tif", package="gdalraster")
#'
#' ## command-line arguments for gdalwarp
#' ## resample to 90-m resolution using average and keep pixels aligned:
#' args = c("-tr", "90", "90", "-r", "average", "-tap")
#' ## output to Erdas Imagine format (HFA), creation option for compression:
#' args = c(args, "-of", "HFA", "-co", "COMPRESSED=YES")
#'
#' alb83_file <- paste0(tempdir(), "/", "storml_elev_alb83.img")
#' warp(elev_file, alb83_file, t_srs="EPSG:5070", cl_arg = args)
#' 
#' ds <- new(GDALRaster, alb83_file, read_only=TRUE)
#' ds$getDriverLongName()
#' ds$getProjectionRef()
#' ds$res()
#' ds$getStatistics(band=1, approx_ok=FALSE, force=TRUE)
#' ds$close()
warp <- function(src_files, dst_filename, t_srs, cl_arg = NULL) {
    invisible(.Call(`_gdalraster_warp`, src_files, dst_filename, t_srs, cl_arg))
}

#' Raster overlay for unique combinations
#' 
#' @description
#' `combine()` overlays multiple rasters so that a unique ID is assigned to 
#' each unique combination of input values. The input raster layers  
#' typically have integer data types (floating point will be coerced to 
#' integer by truncation), and must have the same projection, extent and cell 
#' size. Pixel counts for each unique combination are obtained, and 
#' combination IDs are optionally written to an output raster.
#'
#' Called from and documented in R/gdalraster_proc.R
#' @noRd
.combine <- function(src_files, var_names, bands, dst_filename = "", fmt = "", dataType = "UInt32", options = NULL) {
    .Call(`_gdalraster__combine`, src_files, var_names, bands, dst_filename, fmt, dataType, options)
}

#' @noRd
.has_geos <- function() {
    .Call(`_gdalraster__has_geos`)
}

#' @noRd
.g_create <- function(xy, geom_type) {
    .Call(`_gdalraster__g_create`, xy, geom_type)
}

#' @noRd
.g_is_valid <- function(geom) {
    .Call(`_gdalraster__g_is_valid`, geom)
}

#' @noRd
.g_intersects <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_intersects`, this_geom, other_geom)
}

#' @noRd
.g_equals <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_equals`, this_geom, other_geom)
}

#' @noRd
.g_disjoint <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_disjoint`, this_geom, other_geom)
}

#' @noRd
.g_touches <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_touches`, this_geom, other_geom)
}

#' @noRd
.g_contains <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_contains`, this_geom, other_geom)
}

#' @noRd
.g_within <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_within`, this_geom, other_geom)
}

#' @noRd
.g_crosses <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_crosses`, this_geom, other_geom)
}

#' @noRd
.g_overlaps <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_overlaps`, this_geom, other_geom)
}

#' @noRd
.g_buffer <- function(geom, dist, quad_segs = 30L) {
    .Call(`_gdalraster__g_buffer`, geom, dist, quad_segs)
}

#' @noRd
.g_intersection <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_intersection`, this_geom, other_geom)
}

#' @noRd
.g_union <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_union`, this_geom, other_geom)
}

#' @noRd
.g_difference <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_difference`, this_geom, other_geom)
}

#' @noRd
.g_sym_difference <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_sym_difference`, this_geom, other_geom)
}

#' @noRd
.g_distance <- function(this_geom, other_geom) {
    .Call(`_gdalraster__g_distance`, this_geom, other_geom)
}

#' @noRd
.g_length <- function(geom) {
    .Call(`_gdalraster__g_length`, geom)
}

#' @noRd
.g_area <- function(geom) {
    .Call(`_gdalraster__g_area`, geom)
}

#' @noRd
.g_centroid <- function(geom) {
    .Call(`_gdalraster__g_centroid`, geom)
}

#' Inverse project geospatial x/y coordinates to longitude/latitude
#'
#' `inv_project()` transforms geospatial x/y coordinates to 
#' longitude/latitude in the same geographic coordinate system used by the 
#' given projected spatial reference system. The output long/lat can 
#' optionally be set to a specific geographic coordinate system by specifying 
#' a well known name (see Details).
#'
#' @details
#' By default, the geographic coordinate system of the projection specified 
#' by `srs` will be used. If a specific geographic coordinate system is 
#' desired, then `well_known_gcs` can be set to one of the values below:
#' \tabular{rl}{
#'  `EPSG:n` \tab where `n` is the code of a geographic CRS\cr
#'  `WGS84`  \tab same as `EPSG:4326`\cr
#'  `WGS72`  \tab same as `EPSG:4322`\cr
#'  `NAD83`  \tab same as `EPSG:4269`\cr
#'  `NAD27`  \tab same as `EPSG:4267`\cr
#'  `CRS84`  \tab same as `WGS84`\cr
#'  `CRS72`  \tab same as `WGS72`\cr
#'  `CRS27`  \tab same as `NAD27`
#' }
#' The returned array will always be in longitude, latitude order 
#' (traditional GIS order) regardless of the axis order defined for the 
#' names above.
#'
#' `inv_project()` is included here as a convenience function mainly for 
#' internal use. See package `sf` for more full-featured  
#' coordinate transformation (\url{https://r-spatial.github.io/sf/}).
#'
#' @param pts Numeric array of geospatial x/y coordinates 
#' @param srs Character string in OGC WKT format specifying the projected 
#' spatial reference system for `pts`.
#' @param well_known_gcs Optional character string containing a supported 
#' well known name of a geographic coordinate system (see Details for 
#' supported values).
#' @returns Numeric array of longitude, latitude. An error is raised if the 
#' transformation cannot be performed.
#' @seealso
#' [transform_xy()]
#' @examples
#' pt_file <- system.file("extdata/storml_pts.csv", package="gdalraster")
#' ## id, x, y in NAD83 / UTM zone 12N
#' pts <- read.csv(pt_file)
#' inv_project(as.matrix(pts[,-1]), epsg_to_wkt(26912))
#' inv_project(as.matrix(pts[,-1]), epsg_to_wkt(26912), "NAD27")
inv_project <- function(pts, srs, well_known_gcs = "") {
    .Call(`_gdalraster_inv_project`, pts, srs, well_known_gcs)
}

#' Transform geospatial x/y coordinates
#'
#' `transform_xy()` transforms geospatial x/y coordinates to a new projection.
#'
#' @note
#' `transform_xy()` is included here as a convenience function mainly for 
#' internal use. See package `sf` for more full-featured 
#' coordinate transformation (\url{https://r-spatial.github.io/sf/}).
#'
#' @param pts Numeric array of geospatial x/y coordinates 
#' @param srs_from Character string in OGC WKT format specifying the  
#' spatial reference system for `pts`.
#' @param srs_to Character string in OGC WKT format specifying the output 
#' spatial reference system.
#' @returns Numeric array of geospatial x/y coordinates in the projection 
#' specified by `srs_to`.
#'
#' @seealso
#' [epsg_to_wkt()], [srs_to_wkt()], [inv_project()]
#' @examples
#' pt_file <- system.file("extdata/storml_pts.csv", package="gdalraster")
#' pts <- read.csv(pt_file)
#' ## id, x, y in NAD83 / UTM zone 12N
#' ## transform to NAD83 / CONUS Albers
#' transform_xy( pts = as.matrix(pts[,-1]), 
#'               srs_from = epsg_to_wkt(26912), 
#'               srs_to = epsg_to_wkt(5070) )
transform_xy <- function(pts, srs_from, srs_to) {
    .Call(`_gdalraster_transform_xy`, pts, srs_from, srs_to)
}

#' Convert spatial reference from EPSG code to OGC Well Known Text
#'
#' `epsg_to_wkt()` exports the spatial reference for an EPSG code to 
#' WKT format.
#'
#' @details
#' As of GDAL 3.0, the default format for WKT export is OGC WKT 1.
#' The WKT version can be overridden by using the `OSR_WKT_FORMAT` 
#' configuration option (see [set_config_option()]).
#' Valid values are one of: `SFSQL`, `WKT1_SIMPLE`, `WKT1`, `WKT1_GDAL`, 
#' `WKT1_ESRI`, `WKT2_2015`, `WKT2_2018`, `WKT2`, `DEFAULT`.
#' If `SFSQL`, a WKT1 string without AXIS, TOWGS84, AUTHORITY or 
#' EXTENSION node is returned. If `WKT1_SIMPLE`, a WKT1 string without 
#' AXIS, AUTHORITY or EXTENSION node is returned. `WKT1` is an alias of 
#' `WKT1_GDAL`. `WKT2` will default to the latest revision implemented 
#' (currently `WKT2_2018`). `WKT2_2019` can be used as an alias of 
#' `WKT2_2018` since GDAL 3.2
#'
#' @param epsg Integer EPSG code.
#' @param pretty Logical. `TRUE` to return a nicely formatted WKT string 
#' for display to a person. `FALSE` for a regular WKT string (the default).
#' @return Character string containing OGC WKT.
#'
#' @seealso
#' [srs_to_wkt()]
#'
#' @examples
#' epsg_to_wkt(5070)
#' writeLines(epsg_to_wkt(5070, pretty=TRUE))
#' set_config_option("OSR_WKT_FORMAT", "WKT2")
#' writeLines(epsg_to_wkt(5070, pretty=TRUE))
#' set_config_option("OSR_WKT_FORMAT", "")
epsg_to_wkt <- function(epsg, pretty = FALSE) {
    .Call(`_gdalraster_epsg_to_wkt`, epsg, pretty)
}

#' Convert spatial reference definition to OGC Well Known Text
#'
#' `srs_to_wkt()` converts a spatial reference system (SRS) definition 
#' in various text formats to WKT. The function will examine the input SRS, 
#' try to deduce the format, and then export it to WKT.
#'
#' @details
#' This is a wrapper for `OSRSetFromUserInput()` in the GDAL Spatial 
#' Reference System C API with output to WKT. 
#' The input SRS may take the following forms:
#'   * `WKT` - to convert WKT versions (see below)
#'   * `EPSG:n` - EPSG code n
#'   * \code{AUTO:proj_id,unit_id,lon0,lat0} - WMS auto projections
#'   * `urn:ogc:def:crs:EPSG::n` - OGC urns
#'   * PROJ.4 definitions
#'   * `filename` - file read for WKT, XML or PROJ.4 definition
#'   * well known name such as `NAD27`, `NAD83`, `WGS84` or `WGS72`
#'   * `IGNF:xxxx`, `ESRI:xxxx` - definitions from the PROJ database
#'   * PROJJSON (PROJ >= 6.2)
#'
#' This function is intended to be flexible, but by its nature it is 
#' imprecise as it must guess information about the format intended. 
#' [epsg_to_wkt()] could be used instead for EPSG codes.
#'
#' As of GDAL 3.0, the default format for WKT export is OGC WKT 1.
#' The WKT version can be overridden by using the `OSR_WKT_FORMAT` 
#' configuration option (see [set_config_option()]).
#' Valid values are one of: `SFSQL`, `WKT1_SIMPLE`, `WKT1`, `WKT1_GDAL`, 
#' `WKT1_ESRI`, `WKT2_2015`, `WKT2_2018`, `WKT2`, `DEFAULT`.
#' If `SFSQL`, a WKT1 string without AXIS, TOWGS84, AUTHORITY or 
#' EXTENSION node is returned. If `WKT1_SIMPLE`, a WKT1 string without 
#' AXIS, AUTHORITY or EXTENSION node is returned. `WKT1` is an alias of 
#' `WKT1_GDAL`. `WKT2` will default to the latest revision implemented 
#' (currently `WKT2_2018`). `WKT2_2019` can be used as an alias of 
#' `WKT2_2018` since GDAL 3.2
#'
#' @param srs Character string containing an SRS definition in various
#' formats (see Details).
#' @param pretty Logical. `TRUE` to return a nicely formatted WKT string 
#' for display to a person. `FALSE` for a regular WKT string (the default).
#' @return Character string containing OGC WKT.
#'
#' @seealso
#' [epsg_to_wkt()]
#'
#' @examples
#' srs_to_wkt("NAD83")
#' writeLines(srs_to_wkt("NAD83", pretty=TRUE))
#' set_config_option("OSR_WKT_FORMAT", "WKT2")
#' writeLines(srs_to_wkt("NAD83", pretty=TRUE))
#' set_config_option("OSR_WKT_FORMAT", "")
srs_to_wkt <- function(srs, pretty = FALSE) {
    .Call(`_gdalraster_srs_to_wkt`, srs, pretty)
}

#' Check if WKT definition is a geographic coordinate system
#'
#' `srs_is_geographic()` will attempt to import the given WKT string as a 
#' spatial reference system, and returns `TRUE`  if the root is a 
#' GEOGCS node. This is a wrapper for `OSRIsGeographic()` in the GDAL Spatial 
#' Reference System C API.
#'
#' @param srs Character OGC WKT string for a spatial reference system
#' @return Logical. `TRUE` if `srs` is geographic, otherwise `FALSE`
#'
#' @seealso
#' [srs_is_projected()]
#'
#' @examples
#' srs_is_geographic(epsg_to_wkt(5070))
#' srs_is_geographic(srs_to_wkt("WGS84"))
srs_is_geographic <- function(srs) {
    .Call(`_gdalraster_srs_is_geographic`, srs)
}

#' Check if WKT definition is a projected coordinate system
#'
#' `srs_is_projected()` will attempt to import the given WKT string as a 
#' spatial reference system (SRS), and returns `TRUE` if the SRS contains a 
#' PROJCS node indicating a it is a projected coordinate system. This is a 
#' wrapper for `OSRIsProjected()` in the GDAL Spatial Reference System C API.
#'
#' @param srs Character OGC WKT string for a spatial reference system
#' @return Logical. `TRUE` if `srs` is projected, otherwise `FALSE`
#'
#' @seealso
#' [srs_is_geographic()]
#'
#' @examples
#' srs_is_projected(epsg_to_wkt(5070))
#' srs_is_projected(srs_to_wkt("WGS84"))
srs_is_projected <- function(srs) {
    .Call(`_gdalraster_srs_is_projected`, srs)
}

#' Get the bounding box of a geometry specified in OGC WKT format.
#'
#' `bbox_from_wkt()` returns the bounding box of a WKT 2D geometry 
#' (e.g., LINE, POLYGON, MULTIPOLYGON).
#'
#' @param wkt Character. OGC WKT string for a simple feature 2D geometry.
#' @return Numeric vector of length four containing the xmin, ymin, 
#' xmax, ymax of the geometry specified by `wkt`.
#'
#' @seealso
#' [bbox_to_wkt()]
#'
#' @examples
#' bnd <- "POLYGON ((324467.3 5104814.2, 323909.4 5104365.4, 323794.2 
#' 5103455.8, 324970.7 5102885.8, 326420.0 5103595.3, 326389.6 5104747.5, 
#' 325298.1 5104929.4, 325298.1 5104929.4, 324467.3 5104814.2))"
#' bbox_from_wkt(bnd)
bbox_from_wkt <- function(wkt) {
    .Call(`_gdalraster_bbox_from_wkt`, wkt)
}

#' Convert a bounding box to POLYGON in OGC WKT format.
#'
#' `bbox_to_wkt()` returns a WKT POLYGON string for the given bounding box.
#'
#' @param bbox Numeric vector of length four containing xmin, ymin, 
#' xmax, ymax.
#' @return Character string for an OGC WKT polygon.
#'
#' @seealso
#' [bbox_from_wkt()]
#'
#' @examples
#' elev_file <- system.file("extdata/storml_elev.tif", package="gdalraster")
#' ds <- new(GDALRaster, elev_file, read_only=TRUE)
#' bbox_to_wkt(ds$bbox())
#' ds$close()
bbox_to_wkt <- function(bbox) {
    .Call(`_gdalraster_bbox_to_wkt`, bbox)
}

